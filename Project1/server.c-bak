#include <stdio.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#define BUFFER_SIZE 4096
#define HEADER_SIZE 1024
#define NAME_SIZE 512
#define TYPE_SIZE 64
#define PORT 60023

int file_size(char *filename);
void str_lower(char *str);

int main(void){
	// declare integers to contain socket identifier's
	int server_socket, new_socket;

	printf("STATUS: creating socket\n");
	// create the socket for listening for incoming traffic
	if ((server_socket = socket(AF_INET, SOCK_STREAM, 0))<0){
		//if the socket could not be created, end the process
		fprintf(stderr, "ERROR: could not create socket\n");
		return 0;
	}

	printf("STATUS: creating address\n");
	// create the address for the listening socket
	struct sockaddr_in socket_address;
	socket_address.sin_family = AF_INET;
	socket_address.sin_port = htons(PORT);
	socket_address.sin_addr.s_addr = INADDR_ANY;
	int address_length = sizeof(socket_address);

	printf("STATUS: binding socket to address\n");
	// bind the socket to the address
	if (bind(server_socket,(struct sockaddr *)&socket_address,sizeof(socket_address))<0){
		//if the socket cannot be bound to the address, end the process
		fprintf(stderr, "ERROR: could not bind socket to address\n");
		return 0;
	}

	printf("STATUS: setting process to listen to socket\n");
	// set the process to listen on the socket for incoming data
	if (listen(server_socket,5)<0){
		// if the process is unable to listen to the socket, end the process
		fprintf(stderr, "ERROR: could not listen to socket\n");
		return 0;
	}

	// continually listen for incoming http requests
	while(1)
	{
		printf("STATUS: beginning server listening process\n");

		//listen on the port, so long as we have not recieved valid data
		while((new_socket=accept(server_socket,(struct sockaddr*)&socket_address,(socklen_t*)&address_length))<0){
			// there was a problem with the data given
			fprintf(stderr, "ERROR: socket could not accept\n");
		}

		// intermediary data holders
		char *delim = " \r\n";
		char file_type[TYPE_SIZE]={0};
		char status_type[TYPE_SIZE]={0};
		char buffer[BUFFER_SIZE]={0};
		char filename[NAME_SIZE]={0};
		char header[HEADER_SIZE]={0};
		char *file_extension=NULL;
		char *temp=NULL;
		int status_code;
		int body_size;

		// Read the incoming data into the buffer
		printf("STATUS: reading incoming message into buffer\n");
		read(new_socket, buffer, BUFFER_SIZE);
		printf("%s\n", buffer);

		// Tokenize the data into individual components, so they can be used for data
		printf("STATUS: tokenizing buffer\n");
		if ((temp=strtok(buffer,delim))!=NULL){
			do{
				if(strcmp(temp,"GET")==0){
					temp = strtok(NULL, delim);
					strcpy(filename, temp);
					int i;

					//truncate the filename to all lower case
					str_lower(filename);

					//identify the extension of the file
					for (i=0; filename[i]!='\0'; i++){
						if (filename[i]=='.'){
							file_extension=&(filename[i+1]);
							break;
						}
					}
					break;
				}
			}while((temp=strtok(NULL, delim))!=NULL);
		}

		// check the formatting of the filename
		if (filename[1]==0 || filename[0]==0){
			// no file name was given, default to index.html
			strcpy(filename, "/index.html");
			file_extension = &filename[7];
		}
		else if (file_extension==NULL){
			// no extension was given with the filename, default to HTML
			int i =strlen(filename);
			strcat(filename,".html");
			file_extension=&filename[i+1];
		}
		else if (strcmp(file_extension, "htm")==0){
			// the extension was given as htm, truncate to html
			strcat(filename,"l");
		}

		// Figure out the status of the message, and the size of the file
		printf("STATUS: constructing outgoing message\n");
		if ((body_size = file_size(&filename[1]))<0){
			// The file was not found, send 404 page
			status_code=404;
			strcpy(status_type, "Not Found");

			body_size=file_size("404.html");
			strcpy(filename,"/404.html");
			file_extension = &filename[5];
		}
		else{
			// The file was found, send 200 OK with file
			status_code=200;
			strcpy(status_type, "OK");
			printf("STATUS: file %s is %d bytes\n", &filename[1], body_size);
		}

		//identify the file type based off the extension
		if (strcmp(file_extension,"txt")==0 || strcmp(file_extension, "html")==0 || strcmp(file_extension, "css")==0 || strcmp(file_extension, "js")==0)
			strcpy(file_type,"text");
		else if (strcmp(file_extension,"gif")==0 || strcmp(file_extension, "png")==0 || strcmp(file_extension, "bmp")==0 || strcmp(file_extension, "jpg")==0 || strcmp(file_extension, "jpeg")==0 || strcmp(file_extension,"ico")==0)
			strcpy(file_type,"image");
		else if (strcmp(file_extension,"mp3")==0 || strcmp(file_extension,"wav")==0 || strcmp(file_extension, "wma")==0 || strcmp(file_extension,"ogg")==0)
			strcpy(file_type,"audio");
		else if (strcmp(file_extension,"mp4")==0 || strcmp(file_extension,"wmv")==0)
			strcpy(file_type,"video");
		else if (0) //no application file type set upt to work yet
			strcpy(file_type,"application");
		else{
			strcpy(file_type,"text");
			strcpy(file_type,"plain");
		}

		// create the header for the outgoing file based on the data collected so far
		sprintf(header,"HTTP/1.1 %d %s\nContent-Type: %s/%s\nContent-Length: %d\n\n", status_code, status_type, file_type, file_extension, body_size);

		// Send the header through the port
		printf("STATUS: sending header to client:\n%s",header);
		write(new_socket,header,strlen(header));

		//if the file exists, open it, and add it to the message
		if (body_size>0){
			printf("STATUS: opening file for output stream\n");
			char *file_buffer = (char*)malloc(body_size);
			FILE *fp = fopen(&filename[1],"rb");

			if (fp!=NULL){
				printf("STATUS: reading file into the buffer\n");
				fread(file_buffer,1,body_size,fp);
				fclose(fp);

				printf("STATUS: sending buffer to client\n");
				send(new_socket,file_buffer,body_size,MSG_NOSIGNAL);
			}
			else{
				printf("STATUS: file could not be opened\n");
				fprintf(stderr,"ERROR: file could not be opened\n");
			}
			free(file_buffer);
		}
		close(new_socket);
	}

	close(server_socket);

	return 0;
}



// give the size of the requested file, -1 means it couldn't be found
int file_size(char *filename){
	int size=0;
	FILE *fp = fopen(filename,"rb");
	if (fp!=NULL){
		fseek(fp, 0, SEEK_END);
		size = ftell(fp);
		fclose(fp);
	}
	else{
		return -1;
	}
	return size;
}



// convert upercase characters in the string to lowercase
void str_lower(char *str){
	int i;

	for (i=0; str[i]!='\0'; i++)
		if (str[i]>='A' && str[i]<='Z')
			str[i]+='a'-'A';
}
